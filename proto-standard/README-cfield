
The correctionField makes me mad. We used to have ppi->cField, that
nobody knows which frame it refers to.  I now keep it for reference,
associated to the sync message, so we know what the overall TC delay is.

####################################### E2E

I call the cFields Csyn, Creq, Crep. TC delays are TCsyn ecc.
The times are split in integer and fractional parts: T1 = Ii+F1.
I call the time in the ppsi structures P1, P2, P3, P4

The master sends T1 split sith Csyn = F1 (it is zero for WR). The
slave receives as that (whether there is a f-up or not is irrelevant;
TC will turn one-step into two-step messaging.

   T1 = I1
   Csyn = F1
   Cfup = TCsyn

And ppsi saves P1 as I1 + Csyn:

   P1 = T1 + TCsyn

On transmission, of delay-request nothing happens, and Creq is 0.

   P2 = T2
   P3 = T3

The correction-field arrives with the TC delay inside (TCreq).  The
master copies Creq to Crep and *subtracts* the fractional part of the
timestamp it collected  (NOTE: we always added)

   Crep = TCreq - F4

So, in ppsi I just subtract this:

   P4 = I4 - Crep
   P4 = T4 - TCreq

The cField is received as such, because TC only act on event messages.

Finally, the round trip time is clearly to be calculated as

   T4 - T1 - (T3 - T2)  -  TC

If I do it with ppsi internal stamps:

   P4 - P1 - (P3 - P2)

   T4 - Tcreq - T1 -TCsyn - (T3 - T2)

   T4 - T1 - (T3 - T2)  - (TCsyn + TCreq)

So this actually works as expected.

The unreadble doc says in 11.3, in a 4-line expression, that round-trip is:

   T2 - T3 + (I4 - I1) - Csyn - Cfup - Crep

By expanding  the cFields, this  means:

   T2 - T3 + (I4 - I1) - F1 - TCsyn  - TCreq + F4

   T4 - T1 - (T3 - T2)  - (TCsyn + TCreq)

QED.  So my simplified calculation is correct, and I can merge the
cField in the timestamp as soon as the frame arrives.


#### Bug since the origin of time

Our code has alywas used Crep = F4 (positive), and *added* the cField
to the received timestamp (though only later, not at frame rx time).

Which means that it worked as long as there were no TC in the path,
that it was interoperable with anybody having no fractional part,
and obviously it worked with itself.

But the code is wrong. And if I fix it (by subtracting instead of
adding) it will not be compatible with itself, with the error being
up to two clock cycles.

So I suggest we keep it bugged, well marked in the code, so
somebody else will try to do better in the final HA implementation.
